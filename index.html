<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Nextbot Game</title>
<style>
  body, html {
    margin: 0; padding: 0; height: 100%; overflow: hidden; background: #000;
    font-family: sans-serif;
  }
  #overlay {
    position: absolute;
    top:0; left:0; right:0; bottom:0;
    display: none;
    background: rgba(0,0,0,0.8);
    color: white;
    font-size: 32px;
    text-align: center;
    justify-content: center;
    align-items: center;
    flex-direction: column;
    z-index: 10;
  }
  #overlay button {
    font-size: 24px;
    padding: 10px 20px;
    margin-top: 20px;
    cursor:pointer;
  }
  canvas {
    display: block;
  }
</style>
</head>
<body>
<div id="overlay">
  <div>Game Over</div>
  <button id="restartBtn">Restart</button>
</div>
<script src="https://cdn.jsdelivr.net/npm/three@0.156.1/build/three.min.js"></script>
<script>
(function() {
    THREE.PointerLockControls = function ( camera ) {
        var scope = this;

        camera.rotation.set( 0, 0, 0 );

        var pitchObject = new THREE.Object3D();
        pitchObject.add( camera );

        var yawObject = new THREE.Object3D();
        yawObject.position.y = 1.8;
        yawObject.add( pitchObject );

        var PI_2 = Math.PI / 2;

        var onMouseMove = function ( event ) {
            if ( scope.isLocked === false ) return;

            var movementX = event.movementX || event.mozMovementX || event.webkitMovementX || 0;
            var movementY = event.movementY || event.mozMovementY || event.webkitMovementY || 0;

            yawObject.rotation.y -= movementX * 0.002;
            pitchObject.rotation.x -= movementY * 0.002;

            pitchObject.rotation.x = Math.max( - PI_2, Math.min( PI_2, pitchObject.rotation.x ) );
        };

        document.addEventListener( 'mousemove', onMouseMove, false );

        this.dispose = function() {
            document.removeEventListener( 'mousemove', onMouseMove, false );
        };

        this.getObject = function () {
            return yawObject;
        };

        this.getDirection = function() {
            var direction = new THREE.Vector3( 0, 0, - 1 );
            var rotation = new THREE.Euler( 0, 0, 0, 'YXZ' );
            return function( v ) {
                rotation.set( pitchObject.rotation.x, yawObject.rotation.y, 0 );
                v.copy( direction ).applyEuler( rotation );
                return v;
            };
        }();

        this.isLocked = false;

        var onPointerlockChange = function () {
            if ( document.pointerLockElement === document.body ) {
                scope.isLocked = true;
            } else {
                scope.isLocked = false;
            }
        };

        var onPointerlockError = function () {
            console.error( 'PointerLockControls: Unable to use Pointer Lock API' );
        };

        document.addEventListener( 'pointerlockchange', onPointerlockChange, false );
        document.addEventListener( 'pointerlockerror', onPointerlockError, false );

        this.lock = function () {
            document.body.requestPointerLock();
        };

        this.unlock = function () {
            document.exitPointerLock();
        };
    };
})();
</script>
<script>
const NEXTBOT_IMAGE_URL = "https://raw.githubusercontent.com/nathanmargaglio/Nextbot/refs/heads/main/nextbot_image.png"; // Change to your image URL
const NEXTBOT_SOUND_URL = "https://raw.githubusercontent.com/nathanmargaglio/Nextbot/refs/heads/main/nextbot_sound.mp3"; // Change to your sound URL

let camera, scene, renderer, controls;
let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
let velocity = new THREE.Vector3();
let direction = new THREE.Vector3();

let objects = [];
let boxes = []; 
let boundingBoxes = [];

let nextbot;
let nextbotVelocity = 0.08; // doubled from 0.04 again (4x original)
let playerCollisionRadius = 0.5; 
let nextbotCollisionRadius = 2; // scaled up if nextbot is bigger (original radius was 0.5, now nextbot is 4x bigger)
let gameOver = false;

// For sound
let listener, nextbotSound;
let soundReady = false;
let soundPlayInterval = null;

const overlay = document.getElementById('overlay');
const restartBtn = document.getElementById('restartBtn');
restartBtn.addEventListener('click', restartGame);

init();
animate();

function init() {
  scene = new THREE.Scene();

  camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
  camera.position.set(0, 1.8, 0);

  renderer = new THREE.WebGLRenderer({ antialias:true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  controls = new THREE.PointerLockControls(camera);
  scene.add(controls.getObject());

  document.body.addEventListener('click', () => {
    if (!gameOver) {
      controls.lock();
    }
  }, false);

  // Audio
  listener = new THREE.AudioListener();
  camera.add(listener);

  nextbotSound = new THREE.PositionalAudio(listener);
  const audioLoader = new THREE.AudioLoader();
  audioLoader.load(NEXTBOT_SOUND_URL, (buffer) => {
    nextbotSound.setBuffer(buffer);
    nextbotSound.setRefDistance(10);
    nextbotSound.setLoop(false);
    nextbotSound.setVolume(1);
    soundReady = true;
    scheduleRandomSound();
  });

  const light = new THREE.HemisphereLight(0xffffff, 0x444444, 1.0);
  scene.add(light);

  const dirLight = new THREE.DirectionalLight(0xffffff, 0.5);
  dirLight.position.set(10, 10, 10);
  scene.add(dirLight);

  // Floor
  const floorGeometry = new THREE.PlaneGeometry(200, 200);
  const floorMaterial = new THREE.MeshLambertMaterial({ color:0x555555 });
  const floor = new THREE.Mesh(floorGeometry, floorMaterial);
  floor.rotation.x = -Math.PI/2;
  scene.add(floor);

  generateObstacles(50, 200, 200);

  const textureLoader = new THREE.TextureLoader();
  const nextbotTexture = textureLoader.load(NEXTBOT_IMAGE_URL, () => {
    renderer.render(scene, camera);
  });
  const nextbotGeometry = new THREE.PlaneGeometry(4,4); // Base was (1,1), now 4 times bigger
  const nextbotMaterial = new THREE.MeshBasicMaterial({ map: nextbotTexture, transparent: true });
  nextbot = new THREE.Mesh(nextbotGeometry, nextbotMaterial);
  nextbot.position.set(0,2,-10);
  // Add sound to nextbot object
  nextbot.add(nextbotSound);
  scene.add(nextbot);

  document.addEventListener('keydown', onKeyDown, false);
  document.addEventListener('keyup', onKeyUp, false);
  window.addEventListener('resize', onWindowResize, false);

  resetGame();
}

function scheduleRandomSound() {
  if (!soundReady) return;
  const interval = Math.random() * 10000 + 5000; // between 5 and 15 seconds
  soundPlayInterval = setTimeout(() => {
    if (!gameOver && controls.isLocked && !nextbotSound.isPlaying) {
      nextbotSound.play();
    }
    scheduleRandomSound();
  }, interval);
}

function generateObstacles(count, width, height) {
  objects = [];
  boxes = [];
  boundingBoxes = [];

  for (let i = 0; i < count; i++) {
    let w = (Math.random() * 2 + 1)*2; // twice as large
    let h = (Math.random()*2+1)*2;
    let d = (Math.random() * 2 + 1)*2;
    const boxGeo = new THREE.BoxGeometry(w, h, d);
    const boxMat = new THREE.MeshLambertMaterial({ color:0x888888 });
    const box = new THREE.Mesh(boxGeo, boxMat);
    const posX = (Math.random() - 0.5) * width;
    const posZ = (Math.random() - 0.5) * height;
    if (Math.abs(posX) < 5 && Math.abs(posZ) < 5) {
      continue;
    }
    box.position.set(posX, h/2, posZ);
    scene.add(box);
    objects.push(box);
    boxes.push(box);

    let bbox = new THREE.Box3().setFromObject(box);
    boundingBoxes.push(bbox);
  }
}

function resetGame() {
  gameOver = false;
  overlay.style.display = 'none';
  controls.getObject().position.set(0,1.8,0);
  velocity.set(0,0,0);

  nextbot.position.set((Math.random()-0.5)*50, 2, (Math.random()-0.5)*50);
  nextbotVelocity = 0.08;

  if (soundPlayInterval) clearTimeout(soundPlayInterval);
  scheduleRandomSound();
}

function restartGame() {
  resetGame();
  controls.lock();
}

function onKeyDown(event) {
  switch (event.code) {
    case 'KeyW': moveForward = true; break;
    case 'KeyS': moveBackward = true; break;
    case 'KeyA': moveLeft = true; break;
    case 'KeyD': moveRight = true; break;
  }
}

function onKeyUp(event) {
  switch (event.code) {
    case 'KeyW': moveForward = false; break;
    case 'KeyS': moveBackward = false; break;
    case 'KeyA': moveLeft = false; break;
    case 'KeyD': moveRight = false; break;
  }
}

function onWindowResize() {
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
}

function animate() {
  requestAnimationFrame(animate);

  if (controls.isLocked && !gameOver) {
    const delta = 0.2; // previously was 0.1 * 2, now explicitly 0.2

    velocity.x -= velocity.x * 0.1;
    velocity.z -= velocity.z * 0.1;

    // W = forward, S = backward
    direction.z = Number(moveBackward) - Number(moveForward);
    direction.x = Number(moveRight) - Number(moveLeft);
    direction.normalize();

    if (moveForward || moveBackward) velocity.z -= direction.z * 0.1;
    if (moveLeft || moveRight) velocity.x -= direction.x * 0.1;

    // Player movement + collision
    let playerOldPos = controls.getObject().position.clone();
    controls.getObject().translateX(-velocity.x * delta);
    controls.getObject().translateZ(-velocity.z * delta);

    if (checkCollision(controls.getObject().position, playerCollisionRadius)) {
      controls.getObject().position.copy(playerOldPos);
    }

    // Nextbot movement
    let playerPos = controls.getObject().position.clone();
    let nextbotOldPos = nextbot.position.clone();
    let angleToPlayer = Math.atan2(playerPos.z - nextbot.position.z, playerPos.x - nextbot.position.x);

    // Try direct path
    if (!tryNextbotMove(angleToPlayer, nextbotVelocity)) {
      // If direct path blocked, try slight angles around
      let tryAngles = [angleToPlayer + 0.3, angleToPlayer - 0.3, angleToPlayer + 0.6, angleToPlayer - 0.6];
      let moved = false;
      for (let tryAngle of tryAngles) {
        if (tryNextbotMove(tryAngle, nextbotVelocity)) {
          moved = true;
          break;
        }
      }
      // If none worked, revert to old position (nextbot stays still)
      if (!moved) nextbot.position.copy(nextbotOldPos);
    }

    let dx = playerPos.x - nextbot.position.x;
    let dz = playerPos.z - nextbot.position.z;
    let distance = Math.sqrt(dx*dx + dz*dz);

    nextbot.rotation.y = -Math.atan2(dz, dx) + Math.PI/2;

    // Adjust sound volume based on distance (closer = louder)
    if (soundReady && nextbotSound.isPlaying) {
      // Let's say volume decreases linearly with distance, min volume at some max dist
      let maxDist = 50; 
      let vol = 1 - (distance / maxDist);
      if (vol < 0) vol = 0;
      nextbotSound.setVolume(vol);
    }

    if (distance < (playerCollisionRadius + nextbotCollisionRadius)) {
      gameO
